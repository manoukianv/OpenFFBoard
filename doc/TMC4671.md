# TMC4671 Class State Machine Documentation

This document describes the operation of the state machine for the `TMC4671` class, which is responsible for controlling the Trinamic TMC4671 motor driver.

## 1. Possible States

The `TMC_ControlState` enum defines all possible states of the machine:

```cpp
enum class TMC_ControlState : uint32_t {
    uninitialized,
    waitPower,
    Shutdown,
    Running,
    EncoderInit,
    EncoderFinished,
    HardError,
    OverTemp,
    IndexSearch,
    FullCalibration,
    ExternalEncoderInit,
    Pidautotune,
    CoggingCalibration,
    SlewRateCalibration
};
```

## 2. State Control Variables

- `TMC_ControlState state`: Contains the current state of the machine.
- `TMC_ControlState laststate`: Saves the previous state before a transition to a temporary state (like a calibration), allowing a return to the normal operating state.
- `TMC_ControlState requestedState`: The desired destination state. The transition only occurs if `allowStateChange` is true.
- `bool allowStateChange`: A lock that prevents state changes during critical operations to ensure their complete execution.

## 3. Transition Mechanism

The `changeState(TMC_ControlState newState, bool force = false)` method manages transitions:
- **`force = true`**: The state change is immediate (`state = newState`). Used for critical or internal machine transitions.
- **`force = false`**: The request is stored in `requestedState`. The actual transition occurs in the main `Run()` loop when `allowStateChange` is `true`.

## 4. Detailed Description of States and Transitions

The main logic is implemented in the `Run()` method, which is an infinite loop containing a `switch` on the current state.

---

### **State: `uninitialized`**
- **Role**: First state on startup.
- **Actions**:
    1. Attempts to communicate with the TMC4671 driver via the `pingDriver()` function.
    2. If communication is successful, calls `initialize()` to write the basic configuration (PWM frequency, motor type, etc.).
- **Transitions**:
    - **➡️ `waitPower`**: If `pingDriver()` and `initialize()` succeed.
    - **(Stays)**: If `pingDriver()` fails, remains in this state and retries after a delay.
- **Associated Commands**: No direct user commands. This is an automatic initialization step.

---

### **State: `waitPower`**
- **Role**: Wait for the motor power supply to be stable and sufficient.
- **Actions**:
    1. Periodically checks the supply voltage via `hasPower()`.
    2. Once the voltage is stable, calls `initializeWithPower()`, which performs ADC calibration.
- **Transitions**:
    - **➡️ `EncoderInit`** or **`ExternalEncoderInit`**: If the power is stable but the encoder is not yet aligned (`!encoderAligned`).
    - **➡️ `requestedState`** (usually `Running` or `Shutdown`): If the power is stable and the encoder is already aligned.
    - **(Stays)**: As long as `hasPower()` returns `false`.
- **Special Logic**: If a voltage loss is detected in another state (e.g., `Running`), the machine immediately switches to `waitPower` to ensure a clean recovery when the voltage returns.

---

### **State: `Shutdown`**
- **Role**: A safe resting state where the motor is stopped.
- **Actions**:
    1. Ensures that PWM is disabled (`setPwm(TMC_PwmMode::off)`).
    2. The motor is freewheeling or braked, depending on the hardware configuration.
- **Transitions**:
    - **➡️ `Running`**: Triggered by a call to `startMotor()`.
- **Associated Commands**: `stopMotor()` leads to this state.

---

### **State: `Running`**
- **Role**: The main operational state where the motor is active and controlled.
- **Actions**:
    1. Applies the requested torque, velocity, or position.
    2. Continuously monitors the driver status (`statusCheck()`), temperature (`getTemp()`), and the hardware emergency stop status.
    3. Applies torque compensation (anti-cogging) if enabled.
- **Transitions**:
    - **➡️ `waitPower`**: If an undervoltage is detected.
    - **➡️ `OverTemp`**: If the temperature exceeds the configured limit.
    - **➡️ `Shutdown`**: Triggered by a call to `stopMotor()`.
- **Associated Commands**: `turn()`, `setTargetPos()`, `setTargetVelocity()`.

---

### **Encoder Initialization States: `EncoderInit` & `ExternalEncoderInit`**
- **Role**: Manage the complex sequence of aligning the encoder with the motor.
- **Actions**:
    - This is a "super-state" that executes a sequence of sub-steps:
        1. `estimateABNparams()` / `calibrateAenc()`: Estimates encoder parameters.
        2. `findEncoderIndex()`: Searches for the encoder's index pulse (if configured).
        3. `bangInitEnc()`: Forces an angle on the motor with high current to determine the offset between the electrical position and the encoder position.
        4. `checkEncoder()`: Verifies that the encoder correctly follows the motor's movement.
- **Transitions**:
    - **➡️ `EncoderFinished`**: If all steps succeed.
    - **➡️ `HardError`**: If a step fails repeatedly.
- **Special Logic**: This state is critical and cannot be interrupted (`allowStateChange = false`).

---

### **State: `EncoderFinished`**
- **Role**: A transient state marking the end of encoder initialization.
- **Actions**:
    1. Sets the `encoderAligned` flag to `true`.
- **Transitions**:
    - **➡️ `Running`**: If a motor start was requested (`motorEnabledRequested`).
    - **➡️ `Shutdown`**: Otherwise, waits in a safe mode.

---

### **Calibration States: `FullCalibration`, `Pidautotune`, `CoggingCalibration`, `SlewRateCalibration`**
- **Role**: Execute specific calibration routines initiated by the user.
- **Actions**:
    - Each state executes a specific calibration algorithm (e.g., `calibrateCogging()` measures the motor's detent torque).
- **Transitions**:
    - **➡️ `laststate`**: After the calibration is finished, the machine returns to the previous state (usually `Running` or `Shutdown`).
- **Associated Commands**: `calibrate`, `pidautotune`, `calibrateCogging`.
- **Special Logic**: These states are blocking (`allowStateChange = false`).
- **Prerequisites**: For the calibrations to work correctly, the motor must be in a fully initialized state (encoder aligned, etc.) and powered. The state machine checks for power (`hasPower()`) before launching the routine.

---

### **Error States: `HardError` & `OverTemp`**
- **Role**: Handle critical error conditions.
- **`OverTemp`**:
    - **Cause**: Driver temperature is too high.
    - **Action**: Immediately stops the motor.
    - **Transition**: **➡️ `HardError`**.
- **`HardError`**:
    - **Cause**: Unrecoverable error (ADC calibration failure, repeated encoder alignment failure, overheating).
    - **Action**: Blocks the state machine. The driver is completely disabled.
    - **Transition**: None. A hardware reset is required to exit this state.

## 5. Notable Points and Potential "Illogisms"

1.  **Complex Transition Management**: The `requestedState` and `allowStateChange` system is powerful but can make debugging difficult. A user command may not have an immediate effect if the machine is in a critical state that has locked transitions.
2.  **Recovery after Power Loss**: The systematic transition to `waitPower` in case of undervoltage is a good design practice, as it ensures the system will not attempt to operate under unstable conditions and will re-initialize correctly (re-calibrating ADCs, etc.) when power is restored.
3.  **`HardError` is a Final State**: Once in the `HardError` state, the system is blocked. This is a safety measure, but it means that no software recovery attempt is possible without a restart.
4.  **Encoder Initialization Sequence**: The `encoderInit()` function is the core of the motor's commissioning. It is long and complex, with multiple steps that must succeed. A failure at any stage can lead to an error state, which makes it robust but potentially difficult to diagnose without detailed logs.
5.  **Use of `laststate`**: Storing `laststate` is essential for calibration routines. It allows the user to launch a calibration from the `Running` state and then automatically return to it without manual intervention.

---

## 6. Interaction with User Commands and Safety

When a user command triggers a long action like a calibration (`calibrateCogging`, `pidautotune`, etc.), the `CommandHandler` calls `changeState()` to request a transition to the corresponding calibration state (e.g., `TMC_ControlState::CoggingCalibration`).

The safety of these operations is guaranteed by the following mechanism:

1.  **State Locking**: At the beginning of each calibration state, the `allowStateChange` variable is set to `false`. This "locks" the state machine, preventing any new command or event (like a power loss) from causing an unexpected state change while the calibration routine is in progress.
2.  **Blocking Execution**: The calibration function (`calibrateCogging()`, `measureMaxSlewRate()`, etc.) is called and runs to completion.
3.  **Unlocking and Return**: Once the calibration is finished, `allowStateChange` is set back to `true`, and a call to `changeState(laststate, false)` is made. This requests the machine to return cleanly to the state it was in before the calibration began (usually `Running` or `Shutdown`).

This model ensures that a calibration cannot be interrupted and that the system cannot end up in an inconsistent state following a user command.
